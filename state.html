<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
  <script src="https://unpkg.com/react@17.0.2/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
    function MinutesToHours() {
      // 리액트의  React.useState()는  배열 [undefined, f]을 반환한다, f는 상태를 갱신하는 함수
      // useState()는 다음 코드와 같이 인자에 초기값을 넣을 수 있고 구조분해할당으로 상태관리 한다
      const [amount, setAmount] = React.useState(0);
      const [flipped, setFlipped] = React.useState(false);

      const onChange = (event) => {
        setAmount(event.target.value); // 데이터를 업데이트
      };

      const reset = () => setAmount(0);
      /**
       * onFlip함수에 setFlipped(!flipped)으로 설정한다면 flipped가 컴포넌트 외부에서 업데이트 될 경우  flipped의 결과가 달라질 수 있다
       * 사이드 이펙트를 해결하기 위해
       *! 현재 state를 가지고 새로운 값을 계산할 때 상태갱신함수에 인자로 함수를 넣는다,
       *! 그 함수의 인자는 현재값 current, 리턴 값이 새로운 state가 된다
       */
      const onFlip = () => {
        reset();
        setFlipped((current) => !current);
      };
      return (
        // lavel과 input 태그를 연겷하기 위해 label htlmFor 과 input의 id를 같게 설정한다
        <div>
          <div>
            <label htmlFor="minutes">Minutes</label>
            <input
              value={flipped ? amount * 60 : amount}
              id="minutes"
              placeholder="Minutes"
              type="number"
              onChange={onChange}
              disabled={flipped}
            />
          </div>
          <div>
            <label htmlFor="hours">Hours</label>
            <input
              id="hours"
              value={flipped ? amount : Math.round(amount / 60)}
              placeholder="Hours"
              type="number"
              onChange={onChange}
              disabled={!flipped}
            />
          </div>
          <button onClick={reset}>Reset</button>
          <button onClick={onFlip}>{flipped ? "Turn back" : "Invert"}</button>
        </div>
      );
    }
    function KmToMiles() {
      return <h3>KM 2 M</h3>;
    }
    function App() {
      const [index, setIndex] = React.useState("xx");
      const onSelect = (event) => {
        setIndex(event.target.value);
      };

      // option 태그에 value 속성을 추가해서 옵션이 바뀔때마다(value가 바뀔때마다) 렌더링되는 컴포넌트를 다르게 한다
      return (
        <div>
          <h1>Super Converter</h1>
          <select value={index} onChange={onSelect}>
            <option value="xx">Select your unites</option>
            <option value="0">Minutes & Hours </option>
            <option value="1">Km & Miles</option>
          </select>
          <hr />
          {index === "xx" ? "Please select your units" : null}
          {index === "0" ? <MinutesToHours /> : null}
          {index === "1" ? <KmToMiles /> : null}
        </div>
      );
    }

    // app 컴포넌트가  root에 담기고 렌더링된다, state는 값이 변경될 때 마다 해당컴포넌트가 재렌더링 된다
    // 리액트는 컴포넌트가 재랜더링 될 때 UI에서 바뀐부분만 업데이트하기 때문에 상호작용이 많은 UI를 만들기 용이하다
    const root = document.getElementById("root");
    ReactDOM.render(<App />, root);
  </script>
</html>

<!--
ReactJS는 어플리케이션을 interactive 하게 만들어주는 library
react-dom은 library, 또는 패키지. 모든 react element들을 html body에 둘 수 있도록 해준다.
-->
